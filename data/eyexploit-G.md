# Unused custom errors should be removed
Larger the code base, larger the bytecode will be generated. These bytecode is responsible for total deployment cost. Unused custom errors will only increase the size of bytecode and hence the deployment cost. Its better to remove them if not getting used. 

https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/NFTEDA/NFTEDA.sol#L18

# Use safeTransferFrom for single NFT transfers to save the gas. 
`safeTransferFrom`  are well optimized code, can be used  to save the gas. It is also mentioned on the natspec format, below 
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/interfaces/IPaprController.sol#L115
But did not really applied in the following code. 
```
    /// @inheritdoc IPaprController
    function addCollateral(IPaprController.Collateral[] calldata collateralArr) external override {
        for (uint256 i = 0; i < collateralArr.length;) {
            _addCollateralToVault(msg.sender, collateralArr[i]);
            collateralArr[i].addr.transferFrom(msg.sender, address(this), collateralArr[i].id);
            unchecked {
                ++i;
            }
        }
    }
```

### Gas report

| test/mocks/TestERC721.sol:TestERC721 contract   |                 |        |        |        |         |
|-------------------------------------------------|-----------------|--------|--------|--------|---------|
| Function Name                                   | min             | avg    | median | max    | # calls |
| safeTransferFrom(address,address,uint256)       | 3281            | 17421  | 5521   | 37601  | 15      |
| transferFrom(address,address,uint256)           | 5715            | 24126  | 30915  | 30915  | 14      |
| safeTransferFrom(address,address,uint256,bytes) | 38165           | 125986 | 117056 | 299216 | 48      |
| transferFrom(address,address,uint256)(bool)     | 8915            | 25415  | 30915  | 30915  | 12      |

# MerkleProof can be used to avoid high gas consumption in `setAllowedCollateral`

In future, we might deals with hundred of collaterals in order to put them into allowed list of controller contract. Modifying state by iterating over each and every single address will only lead to high gas consumption. The best approach will be here is to used merkle tree whitelisting mechanism. 

You only need to submit merkleProof in order to validate the collateral address. 


```
    function setAllowedCollateral(IPaprController.CollateralAllowedConfig[] calldata collateralConfigs)
        external
        override
        onlyOwner
    {
        for (uint256 i = 0; i < collateralConfigs.length;) {
            if (collateralConfigs[i].collateral == address(0)) revert IPaprController.InvalidCollateral();

            isAllowed[collateralConfigs[i].collateral] = collateralConfigs[i].allowed;
            emit AllowCollateral(collateralConfigs[i].collateral, collateralConfigs[i].allowed);
            unchecked {
                ++i;
            }
        }
    }
```
